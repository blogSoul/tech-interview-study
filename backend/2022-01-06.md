# 📕 tech-interview-study 자료 기록

## ⏱ 자료 작성 일자

* 회의 일자 : 2022-01-06

[comment]: <> (2021-00-00로 기록해주세요)

* 회의 구분 : BE

[comment]: <> (BE / FE 로 기록해주세요)

* 참여 인원 : 설민욱, 문혜현, 권윤영

[comment]: <> (회의에 참여한 인원을 적어주세요)

## 👏 회의 주제

> 면접 스터디에서 얘기한 내용을 정리합니다.

### 📃 준비해온 질문 :

[comment]: <> (여기에 준비해둔 질문들을 적어주시면 됩니다.)

### 🙋‍♂ 자료 정리 :

* 질문 내용 :

[comment]: <> (질문 내용에 따라 내용을 작성해주시면 됩니다.)

1. 트랜잭션이 독립적인 수행을 할 수 있도록 만들기 위해 Locking 방법을 사용하는데 어떤 공유가 있는가?

* 공유 락(= shared lock) : 데이터를 읽을 때, 사용되어지는 lock

공유락은 공유락끼리 동시에 접근이 가능합니다. 하지만 공유락이 설정된 데이터에 베타 락을 사용할 수 없습니다.

* 배타 락(= exclusive lock) : 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 때까지 유지됩니다.

락이 해제될 때까지 다른 트랜잭션은 해당 리소스에 접근할 수 없습니다.

해당 lock은 트랜잭션이 수행되고 있는 데이터에 대해 Lock을 설정할 수 없습니다.

2. DB 인덱스를 거는 이유? DB 인덱스에 왜 해쉬 보다 B-Tree를 쓰는지?

인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조입니다.

밸런스 트리 중 하나인 B-Tree를 이용하기 때문에 O(logN)만큼 이용할 수 있습니다.

하지만 해시테이블은 O(1)입니다. 그렇기 때문에 왜 쓰이는지 생각해봐야 합니다.

DB 쿼리문에선 = 뿐만 아니라 부등호(<, >)도 사용할 수 있습니다.

해시테이블에서 특정 기준보다 크거나 작은 값을 찾을 수 없습니다.

그렇기 때문에 기준 값보다 크거나 작은 요소들을 항상 탐색할 수 있어야 하는 DB 인덱스이기에 해시 테이블이 어울리지 않습니다.

3. 그렇다면 RedBlack-Tree가 아니라 B-Tree가 선정이 되었나요?

B-Tree의 노드는 배열로 이루어져 있습니다.

따라서 B-Tree의 배열 형식의 접근과 RedBlack-Tree의 참조 포인터 접근의 시간 차이에 대해 생각해봐야 하는데

참조 포인터로 메모리에 접근한다는 것은 실제 메모리 상 순서대로 저장이 되었든 안 되었든 접근하려는 주소를 연산을 통해 직접 알아내어 데이터에 접근해야 합니다.

따라서 B-Tree가 RedBlack-Tree보다 효율적입니다.

* 배열이 안 쓰이는 이유? 탐색은 B-Tree보다 빠르지만 저장, 삭제가 일어나는 순간 B-Tree보다 훨씬 느립니다.

즉, B-Tree의 특징을 보면 아래와 같습니다.

1. 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없다.
2. 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다.
3. 데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가진다.

4. 트랜잭션 격리 수준과 일어나는 현상에 대해 설명하세요.

* Read Uncommitted (레벨 0)

SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층

트랜잭션에 처리중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함

데이터베이스의 일관성을 유지하는 것이 불가능함

Dirty Read 발생

Ex)

A 트랜잭션에서 10번 사원의 나이를 27에서 28로 바꿈. 아직 커밋하지 않음

B 트랜잭션에서 10번 사원의 나이를 조회 : 결과 28 → 더티 리드(Dirty Read)

이 이후, A 트랜잭션에서 문제가 발생해 Rollback함

B 트랜잭션은 10번 사원이 여전이 28살이라 생각하고 로직을 수행함

이런식으로 데이터 정합성에 문제가 많아짐.

* Read Committed (레벨 1)

SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층

트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨

Commit이 이루어진 트랜잭션만 조회 가능

Oracle DB, SQL Server에서 기본으로 사용하는 Ioslation Level임

Non-Repeatable Read 발생

Ex)

B 트랜잭션에서 10번 사원의 나이를 조회 : 결과 27

A 트랜잭션에서 10번 사원의 나이를 27에서 28로 바꾸고 커밋

B 트랜잭션에서 10번 사원의 나이를 조회 : 결과 28

* Repeatable Read (레벨 2)

트랜잭션이 완료될 때까지 SELECT 문장이 사용되는 모든 데이터에 Shared Lock이 걸리는 계층

트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함

다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능

MySQL DBMS에서 기본으로 사용함

Non-Repeatable Read 부정합이 발생하지 않음

Ex)

10번 트랜잭션이 500번 사원을 조회

12번 트랜잭션이 500번 사원의 이름을 변경하고 커밋

10번 트랜잭션이 500번 사원을 다시 조회 : undo 영역에 백업된 데이터 반환

즉, 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(커밋된) 것만 보게 된다.

모든 InnoDB의 트랜잭션은 순차적으로 증가하는 고유한 트랜잭션 번호를 갖고 있으며,

undo 영역에 백업된 모든 레코드는 변경을 발생시킨 트랜잭션의 번호를 포함하고 있다.

Phantom Read 발생

* Serializable (레벨 3)

트랜잭션이 완료될 때까지 SELECT 문장이 사용되는 모든 데이터가 모든 동작이 직렬화 하게 작동하는 계층

가장 엄격한 격리 수준으로 완벽한 읽기 일관성 모드를 제공함

다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능

레벨이 높아질 수록 트랜잭션간 고립 정도가 높아지며, 성능이 떨어지는 것이 일반적이며, 일반적인 온라인 서비스에서는 READ COMMITTED나 REPEATABLE READ 중 하나를 사용한다.

(Oracle = READ COMMITTED, MySQL = REPEATABLE READ)

* 낮은 단계 Isolation Level을 활용할 때 발생하는 현상들

* Dirty Read

어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우

커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상

* Non-Repeatable Read

한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상

한 트랜잭션에서 똑같은 SELECT를 수행했을 때 항상 같은 결과를 반환해야 한다는 Repeatable Read 정합성에 어긋남

* Phantom Read

한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상

트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타남

serializable와 repeatable read의 차이는 트랜잭션 커밋 순서를 직렬화로 보장하느냐입니다. 먼저 커밋한 놈만 정상 트랜잭션으로 간주하겠다는 것이다.

(물론 각 트랜잭션 내에서 자료 읽기 독립성이 보장된 상태에 한정)

자료 읽기 독립성 - 한 트랜잭션이 한번 읽은 자료는 그 자료를 그 트랜잭션 내에서 바꾸지 않는 한 다른 세션이 그 자료를 조작해서 커밋을 했더라도, 항상 같은 값으로 보여야한다.

![image](https://user-images.githubusercontent.com/42922298/148293157-ebcb14df-76cc-47d2-a18b-73501b2a8098.png)

5. 트랜잭션 격리수준 고려사항은?

Isolation Level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있다.

동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 된다.

레벨을 높게 조정할 수록 발생하는 비용이 증가한다.

무결성(Integrity) : 데이터의 정확성, 일관성, 유효성이 유지되는 것

개체 무결성 : 모든 테이블이 기본키로 선택된 필드를 가져야 한다.(기본키를 가져야 한다.) 고유한 값, NULL 허용 하지 않음.

참조 무결성 : 참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지. 참조 대상이 존재하지 않는 외래 키를 허용하지 않는다.

RESTRICTED : 레코드를 참조하고 있는 개체가 있다면, 변경 또는 삭제 연산을 취소

CASCADE : 레코드를 참조하고 있는 개체도 변경 또는 삭제

SET NULL : 레코드를 참조하고 있는 개체의 값을 NULL로 설정

도메인 무결성 : 테이블에 존재하는 필드의 무결성 보장. 필드의 타입, null값의 허용 등 사항을 정의하고 올바른 데이터가 입력되었는지 확인하는 것

무결성 규칙 : 데이터의 무결성을 지키기 위한 모든 제약 사항을 말한다. 데이터베이스 전체에 공통적으로 적용되는 규칙

* 문혜현

[DB개념](https://cooperative-decision-4e6.notion.site/MongoDB-fc200b09f74245ddaa94391eb3630924)
