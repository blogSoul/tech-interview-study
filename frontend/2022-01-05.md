**클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수다**

### 클로져의 활용

1. 상태 유지
2. 전역 변수의 사용 억제 => 자신이 생성되었을 때의 lexical 환경을 기억하기 때문이다.
3. 정보의 은닉

렉시컬 환경은 두가지 부분을 갖습니다.

*1. 환경 레코드(Environment Record)* – 모든 지역 변수를 프로퍼티로 저장하고 있는 객체입니다. this 값과 같은 기타 정보도 여기에 저장됩니다.


*2. 외부 렉시컬 환경(Outer Lexical Environment)* 에 대한 참조 – 외부 코드와 연관됨

**스코프 체인**

변수는 스코프 체인(Scope Chain)이라는 방식으로 참조됩니다.

(프로퍼티는 프로토타입 체인으로 상위 객체를 참조하는식, 최종 Object의 prototype를 참조하는 식으로 구현됩니다.)

일종의 스코프 체인은 단방향 링크드 리스트로, 전역객체에서 현재 스코프까지의 레퍼런스를 순서대로 저장합니다. 이때 아까 말한 *외부 렉시컬 환경(Outer Lexical Environment)을  사용하여  상위 렉시컬 환경을 참조하게 됩니다.  (*Outer Environment Reference)

this는 언제, 누가 불렀냐에 따라서 다르게 호출됩니다.

1. 전역 상태일경우

this는 전역 객체를 나타냅니다.

2. 객체 안일경우

this는 객체 자신을 가리키도록 바인딩됩니다.

(내부에서 바인딩하는 함수가 따로 있습니다.)

3. 함수 안일경우

this는 동적으로 바인딩되는데, 호출을 누가 했냐에 따라 다르게 바인딩 됩니다.

그냥 함수를 불러와 실행하면 this는 window입니다. (node는 global)

객체가 불러왔으면 this는 객체를 가리킵니다.

그외 this를 변경하는방법은 bind 함수를 실행하는 방법이 있고(한번만 가능)

call, apply로 불러와 실행 가능합니다.

call은 첫번째 객체의 this를 넘기고, 인자로 나머지 매개변수를 받아서 실행 

apply는 첫번째 객채의 this를 넘기고 나머지 매개변수를 배열로 받아서 실행 





## 1. 스코프, 스코프 체인에 대해 설명해주세요

## 2. 0부터 순서대로 출력하고 싶었는데 제대로 작동하지 않습니다.
아래 코드의 문제점과 일어나는 이유, 개선방안을 말해주세요
(힌트 : 클로저)


```jsx
for(var i =0; i <100; i+=1){
    setTimeout(function(){
        console.log(i);
    },i*1000);
}
```

```jsx 
해결방안 
for(let i =0; i <100; i+=1){
    setTimeout(function(){
        console.log(i);
    },i*1000);
}
```
https://www.bangseongbeom.com/javascript-var-let.html


## 3. 함수 호이스팅과 변수 호이스팅의 차이점을 말해주세요.

함수 호이스팅은 선언, 초기화, 할당이 한꺼번에 이루어진다.(함수선언식)

변수 호이스팅은 변수 호이스팅 방식을 따른다(var, const, let 등등) 
함수표현식은 변수 호이스팅 방식을 따른다 

## 4. 함수의 렉시컬 스코프와 상위 스코프를 정하는 방식은 어떻게 정해지나요?

### **렉시컬 스코프란(Lexical Scope)란?**

함수를 어디서 호출하는지가 아니라 어디에 **선언하였는지에 따라 결정되는 것**을 말한다.

즉, 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정한다는 뜻이며, 가장 중요한 점은 함수의 호출이 아니라 **함수의 선언에 따라 결정된다는 점**이다.

함수의 호출에 따라 상위 스코프가 정해지는 것을 **Dynamic Scope**라고도 합니다. Perl, Bash Shell 등에서 Dynamic Scope를 따른다.

## 5. const, var, let 변수의 생성 단계 3단계를 설명해주세요. 

**선언 단계(Declaration phase) :** 변수를 실행 컨텍스트의 변수 객체에 등록하는 단계를 의미합니다. 이 변수 객체는 스코프가 참조하는 대상이 됩니다.

**초기화 단계(Initialization phase) :** 실행 컨텍스트에 존재 하는 변수 객체에 선언 단계의 변수를 위한 메모리를 만드는 단계 입니다. 이 단계에서 할당된 메모리에는 undefined로 초기화 됩니다.

**할당 단계(Assignment phase) :** 사용자가 undefined로 초기화된 메모리의 다른 값을 할당하는 단계 입니다.

var,let,const 모두 위 3단계를 거칩니다.

다만 var는 선언단계와 초기화 단계가 호이스팅 단계에서 동시에 실행됩니다.

let,const는 선언은 되지만 초기화는 되지 않고, 할당이 되기 전까지 TDN(temporal dead zone)이라는 곳에 등록됩니다. 그래서 할당이 되지 않았는데 불러온다면 TDN 구간에 있는 변수들은 참조 에러(Reference Error)를 발생시키게 됩니다.

즉, 호이스팅은 모두 발생하지만 var와 let,const는 다루는 방법에 차이가 있게 되는것입니다.

다른 언어에서 흔히 쓰는 변수들은 구조적으로는 약간씩 다르겠지만 결론적으로 let,const와 동일하게 쓰인다고 이해하시면 편합니다.
