# 📕 tech-interview-study 자료 기록

## ⏱ 자료 작성 일자

* 회의 일자 : 2021-12-28

[comment]: <> (2021-00-00로 기록해주세요)

* 회의 구분 : FE

[comment]: <> (BE / FE 로 기록해주세요)

* 참여 인원 : 김일혁, 문상혁, 이충헌

[comment]: <> (회의에 참여한 인원을 적어주세요)

## 👏 회의 주제

> 면접 스터디에서 얘기한 내용을 정리합니다.

### 📃 준비해온 질문 :

1. Critical Rendering Path를 최적화 하기 위한 방법은 무엇이 있나요?

- media query, media type을 이용한 CSS 최적화
  ```html
  <link href="style.css"    rel="stylesheet">
  <link href="style.css"    rel="stylesheet" media="all">
  <link href="print.css"    rel="stylesheet" media="print">
  <link href="portrait.css" rel="stylesheet" media="orientation:landscape">
  <link href="other.css"    rel="stylesheet" media="min-width: 40em">

  ```
  CSS는 `rendering-blocking-resourece`이다. CSS 파싱해 CSSOM이 생성될때까지 브라우저는 렌더링을 하지 않는다는 뜻이다.
  위와 같은 미디어 쿼리나 미디어 유형을 적어줌으로써 CRP 과정을 최적화할 수 있다.
  미디어 유형에 따라 당장 사용하지 않을 규칙들을 별도의 파일로 분리한 후 '리소스를 다운받긴 하지만 필요한 시점까지 파싱을 지연시킨다'.
  즉 렌더링을 차단하지 않는다.

- JavaScript 최적화
브라우저의 렌더링 엔진은 HTML 문서를 파싱하는 도중 `<script>` 태그를 만나면 JavaScript는 DOM 생성 프로세스를 중지하고 '자바스크렙트 엔진에게 권한을 넘긴다'.
따라서 `<script>` 태그 내부의 내용을 처리하기 전까지 DOM은 생성되지 않는다. JavaScript도 `rendering-blocking-resource`이다.
스크립트를 만약 body 태그가 닫히기 직전으로 이동시키거나 script 태그의 `async`, `defer` 속성을 이용한다면 렌더링을 빠르게 할 수 있다.

- 리소스 우선순위 설정
`preload`, `preconnect`, `prefetch` 등의 속성을 이용해 브라우저가 처리할 리소스의 우선순위를 직접 지정해줄 수 있다.
그렇지 않으면 브라우저는 자기가 알아서 판단해서 우선순위를 부여한다.
  ```html
  <link rel="preload" as="script" href="super-important.js">
  <link rel="preload" as="style" href="critical.css">
  ```

  
2. CRP에서 Layout 과정이 필요한 이유는 무엇인가요?

    Render Tree를 만드는 과정에서 CSSOM이 사용되기는 하나, 현재 viewport 기준으로 정확히 어디에 DOM이 위치할지 모르기 때문이다.

3. babel의 역할은 무엇인가요?

    babel은 ES6 이상의 문법을 지원하지 않는 여러 브라우저들을 위해 작성한 코드를 ES5 이하 버전으로 트랜스파일 시켜주는 도구이다.
    주로 webpack의 loader로써 사용되는데, 이는 babel이 단순히 트랜스파일링에만 관여할 뿐 의존성 문제를 해결해주지 않기 때문이다.
    물론 독자적으로도 사용은 가능하다.


4. JSX 문법은 어떻게 처리되나요?

    JSX 문법은 바벨을 통해 `React.createElement()` 함수로 변환된다.
    JSX와 React를 같이 사용할 때 굳이 당장 React 라이브러리를 사용하지 않더라도 `import React from 'react'`를 해줘야 하는데
    이게 바벨이 트랜스파일 한 `React.createElement()`를 처리해주기 위함이다.


5. `0 == false` 와 `0 === false` 는 어떻게 작동할까요?

    `0 == false`는 동등연산자를 사용한다. 타입이 다른 두 값을 비교할 때 'number 타입'으로 우선 변환하고, `false`는 0과 같기 때문에 해당 문은 true로 평가된다.
    `0 === false`는 일치연산자를 사용했다. 비교시 타입 변환을 시도하지 않기 때문에 타입이 다르면 다르다. 즉 false로 평가된다.


6. Object가 동일한 Object인지 어떻게 체크하나요?

    직접 비교할 수는 없다. 비교 연산자를 사용해 비교하면 얕은 비교를 하기 때문에 내용이 전부 같더라도 메모리 주소가 달라 다른 객체로 평가된다.
    `JSON.stringify`를 이용하면 두 객체의 내부 값이 모두 일치하는 경우에 대해 비교가 가능하다.


7. `undefined`와 `null` 의 차이점은 무엇인가요?

    일단 둘 다 타입이고 객체이다.
    `null` 은 값은 들어있지만 의미없는, 빈 것과 다름 없는 값이라는 뜻이고
    `undefined`는 아예 정의조차 되어있지 않다는 뜻이다.


8. webpack의 4가지 구성 요소를 설명해보세요.

    - entry : 의존성 그래프의 루트에 해당. 번들링의 시작점이 될 파일의 위치
    - output : 결과 파일의 경로와 이름
    - loader (module)
      - 기본적으로 webpack은 `.js` 파일과 `.json` 파일밖에 처리할 수 없다.
      - 그러나 각 모듈이 의존하는 내용을 보면 CSS 파일을 의존할 때도 있고 image, font 파일에 대해 의존성을 가질 수도 있다.
      - loader는 이런 다른 종류의 파일들을 webapck이 처리할 수 있도록 변환해주는 역할을 한다.
      - 전처리 역할도 한다. (ex. babel)
      - sass 파일 처리같이 여러 단계를 거치는 경우에는 오른쪽부터 처리된다.
    - plugin
      - webpack이 번들링을 마친 후 후처리에 해당하는 작업을 진행한다.
      - 생성자 함수를 통해 만들어진 객체만 사용할 수 있다.
      - 주로 난독화, minify 등의 작업이 여기서 진행된다.


9. output의 hash와 chunkhash의 차이란?

    - hash : 웹 캐싱 처리가 안됨. unique has generated for every build
    - chunkhash : 웹 캐싱 처리때 유용.

### 🙋‍♂ 자료 정리 :

* 질문 내용 : 

[comment]: <> (질문 내용에 따라 내용을 작성해주시면 됩니다.)
